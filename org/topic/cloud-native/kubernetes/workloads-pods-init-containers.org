#+SETUPFILE: ~/site/tpl/wiki-tpl.org
#+TITLE: Kubernetes 工作负载：Pod - Init Containers
#+DATE: 2021-04-25 21:11:40

https://kubernetes.io/docs/concepts/workloads/pods/init-containers/

Init containers 是在 Pod 中的应用容器之前运行的专有容器；Init containers 可以包含应用程序镜像中不存在的实用程序和启动脚本。

你可以在 Pod 规范（Spec）中与 =containers= 数组一起指定 init containers。

* 理解 init containers

  Pod 中可以有多个运行应用程序的容器，同时也可以有一个或者多个 init containers，它们会在应用容器启动之前运行。

  Init containers 容器和普通容器一样，除了：

  - Init containers 总是会运行完成；
  - 每个 Init containers 必须成功完成才会启动下一个容器；

  如果 Pod 的 init container 失败了，kubelet 会不断的重启 init container 直到它成功为止。然而，如果 Pod 的 =restartPolicy= 策略为
  Never，并且在 Pod 启动期间 init container 失败了，Kubernetes 会将整个 Pod 视为失败。

  要为 Pod 指定 init container，添加 =initContainers= 字段到 Pod 规格中，作为类型为 [[https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#container-v1-core][Containers]] 的对象数组，与应用的 =containers=
  一起。Init containers 的状态在 =.status.initContainerStatuses= 字段中返回（类似容器的 =.status.containerStatuses= 字段）。

** 与普通容器的不同

   Init containers 支持应用程序容器的所有字段和功能，包括资源限制，卷和安全设置。但是，如 [[https://kubernetes.io/docs/concepts/workloads/pods/init-containers/#resources][资源]] 文档中所说，init container 的资源请求（requests）
   和限制（limits）的处理方式不同。

   另外，init containers 不支持 =lifecycle=, =livenessProbe=, =readinessProbe= 或者 =startupProbe= ，因为它们必须在 Pod ready
   之前才能完成。

   如果你为 Pod 指定了多个 init container，kubelet 会按照 init container 的顺序逐个执行。每个 init containers 必须成功，然后才能运行
   下一个容器。当所有的 init containers 都运行完毕之后，kubelet 会初始化 Pod 的应用程序，并像往常一样初始化它们。

* 使用 init containers

  由于 init containers 和应用容器的镜像是分开的，所以它们在启动相关代码的时候有一些优点：

  - Init containers 可以包含应用程序镜像中不存在的应用程序或者用于设置的自定义代码。比如，无需在安装过程中需要使用到的 =sed= =awke= =python=
    或者 =dig= 等工具引入到另外一个镜像中；
  - 应用程序镜像构建者和部署者的角色可以独立工作，而无需共同构建单个应用程序镜像；
  - Init containers 可以在与同一个 Pod 中的应用程序的不同文件系统视图下运行。因为，可以授予他们应用程序容器无法访问的机密（Secrets）权限；
  - 由于 init containers 在任何应用程序启动之前就已经运行完毕，因此 init containers 提供了一种机器来阻止或者延迟应用程序容器启动，直到满足
    一组先决条件。

* 详细行为

* 下一步
